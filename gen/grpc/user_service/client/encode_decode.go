// Code generated by goa v3.2.4, DO NOT EDIT.
//
// user_service gRPC client encoders and decoders
//
// Command:
// $ goa gen github.com/SantoshSah/user-service-sample/design

package client

import (
	"context"

	user_servicepb "github.com/SantoshSah/user-service-sample/gen/grpc/user_service/pb"
	userservice "github.com/SantoshSah/user-service-sample/gen/user_service"
	userserviceviews "github.com/SantoshSah/user-service-sample/gen/user_service/views"
	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildSignupFunc builds the remote method to invoke for "user_service"
// service "signup" endpoint.
func BuildSignupFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Signup(ctx, reqpb.(*user_servicepb.SignupRequest), opts...)
		}
		return grpccli.Signup(ctx, &user_servicepb.SignupRequest{}, opts...)
	}
}

// EncodeSignupRequest encodes requests sent to user_service signup endpoint.
func EncodeSignupRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.SignupPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "signup", "*userservice.SignupPayload", v)
	}
	return NewSignupRequest(payload), nil
}

// DecodeSignupResponse decodes responses from the user_service signup endpoint.
func DecodeSignupResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.SignupResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "signup", "*user_servicepb.SignupResponse", v)
	}
	res := NewSignupResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildVerifyConfirmationTokenFunc builds the remote method to invoke for
// "user_service" service "verifyConfirmationToken" endpoint.
func BuildVerifyConfirmationTokenFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.VerifyConfirmationToken(ctx, reqpb.(*user_servicepb.VerifyConfirmationTokenRequest), opts...)
		}
		return grpccli.VerifyConfirmationToken(ctx, &user_servicepb.VerifyConfirmationTokenRequest{}, opts...)
	}
}

// EncodeVerifyConfirmationTokenRequest encodes requests sent to user_service
// verifyConfirmationToken endpoint.
func EncodeVerifyConfirmationTokenRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.VerifyConfirmationTokenPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "verifyConfirmationToken", "*userservice.VerifyConfirmationTokenPayload", v)
	}
	return NewVerifyConfirmationTokenRequest(payload), nil
}

// DecodeVerifyConfirmationTokenResponse decodes responses from the
// user_service verifyConfirmationToken endpoint.
func DecodeVerifyConfirmationTokenResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.VerifyConfirmationTokenResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "verifyConfirmationToken", "*user_servicepb.VerifyConfirmationTokenResponse", v)
	}
	res := NewVerifyConfirmationTokenResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildUpdateUsernameFunc builds the remote method to invoke for
// "user_service" service "updateUsername" endpoint.
func BuildUpdateUsernameFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.UpdateUsername(ctx, reqpb.(*user_servicepb.UpdateUsernameRequest), opts...)
		}
		return grpccli.UpdateUsername(ctx, &user_servicepb.UpdateUsernameRequest{}, opts...)
	}
}

// EncodeUpdateUsernameRequest encodes requests sent to user_service
// updateUsername endpoint.
func EncodeUpdateUsernameRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.UpdateUsernamePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "updateUsername", "*userservice.UpdateUsernamePayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewUpdateUsernameRequest(payload), nil
}

// DecodeUpdateUsernameResponse decodes responses from the user_service
// updateUsername endpoint.
func DecodeUpdateUsernameResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.UpdateUsernameResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "updateUsername", "*user_servicepb.UpdateUsernameResponse", v)
	}
	res := NewUpdateUsernameResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildVerifyPasswordResetTokenFunc builds the remote method to invoke for
// "user_service" service "verifyPasswordResetToken" endpoint.
func BuildVerifyPasswordResetTokenFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.VerifyPasswordResetToken(ctx, reqpb.(*user_servicepb.VerifyPasswordResetTokenRequest), opts...)
		}
		return grpccli.VerifyPasswordResetToken(ctx, &user_servicepb.VerifyPasswordResetTokenRequest{}, opts...)
	}
}

// EncodeVerifyPasswordResetTokenRequest encodes requests sent to user_service
// verifyPasswordResetToken endpoint.
func EncodeVerifyPasswordResetTokenRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.VerifyPasswordResetTokenPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "verifyPasswordResetToken", "*userservice.VerifyPasswordResetTokenPayload", v)
	}
	return NewVerifyPasswordResetTokenRequest(payload), nil
}

// DecodeVerifyPasswordResetTokenResponse decodes responses from the
// user_service verifyPasswordResetToken endpoint.
func DecodeVerifyPasswordResetTokenResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.VerifyPasswordResetTokenResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "verifyPasswordResetToken", "*user_servicepb.VerifyPasswordResetTokenResponse", v)
	}
	res := NewVerifyPasswordResetTokenResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildResetPasswordFunc builds the remote method to invoke for "user_service"
// service "resetPassword" endpoint.
func BuildResetPasswordFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.ResetPassword(ctx, reqpb.(*user_servicepb.ResetPasswordRequest), opts...)
		}
		return grpccli.ResetPassword(ctx, &user_servicepb.ResetPasswordRequest{}, opts...)
	}
}

// EncodeResetPasswordRequest encodes requests sent to user_service
// resetPassword endpoint.
func EncodeResetPasswordRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.ResetPasswordPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "resetPassword", "*userservice.ResetPasswordPayload", v)
	}
	return NewResetPasswordRequest(payload), nil
}

// DecodeResetPasswordResponse decodes responses from the user_service
// resetPassword endpoint.
func DecodeResetPasswordResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.ResetPasswordResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "resetPassword", "*user_servicepb.ResetPasswordResponse", v)
	}
	res := NewResetPasswordResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildChangePasswordFunc builds the remote method to invoke for
// "user_service" service "changePassword" endpoint.
func BuildChangePasswordFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.ChangePassword(ctx, reqpb.(*user_servicepb.ChangePasswordRequest), opts...)
		}
		return grpccli.ChangePassword(ctx, &user_servicepb.ChangePasswordRequest{}, opts...)
	}
}

// EncodeChangePasswordRequest encodes requests sent to user_service
// changePassword endpoint.
func EncodeChangePasswordRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.ChangePasswordPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "changePassword", "*userservice.ChangePasswordPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewChangePasswordRequest(payload), nil
}

// DecodeChangePasswordResponse decodes responses from the user_service
// changePassword endpoint.
func DecodeChangePasswordResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.ChangePasswordResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "changePassword", "*user_servicepb.ChangePasswordResponse", v)
	}
	res := NewChangePasswordResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildLoginFunc builds the remote method to invoke for "user_service" service
// "login" endpoint.
func BuildLoginFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Login(ctx, reqpb.(*user_servicepb.LoginRequest), opts...)
		}
		return grpccli.Login(ctx, &user_servicepb.LoginRequest{}, opts...)
	}
}

// EncodeLoginRequest encodes requests sent to user_service login endpoint.
func EncodeLoginRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.LoginPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "login", "*userservice.LoginPayload", v)
	}
	return NewLoginRequest(payload), nil
}

// DecodeLoginResponse decodes responses from the user_service login endpoint.
func DecodeLoginResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.LoginResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "login", "*user_servicepb.LoginResponse", v)
	}
	res := NewLoginResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildRefreshAccessTokenFunc builds the remote method to invoke for
// "user_service" service "refreshAccessToken" endpoint.
func BuildRefreshAccessTokenFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.RefreshAccessToken(ctx, reqpb.(*user_servicepb.RefreshAccessTokenRequest), opts...)
		}
		return grpccli.RefreshAccessToken(ctx, &user_servicepb.RefreshAccessTokenRequest{}, opts...)
	}
}

// EncodeRefreshAccessTokenRequest encodes requests sent to user_service
// refreshAccessToken endpoint.
func EncodeRefreshAccessTokenRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.RefreshAccessTokenPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "refreshAccessToken", "*userservice.RefreshAccessTokenPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewRefreshAccessTokenRequest(payload), nil
}

// DecodeRefreshAccessTokenResponse decodes responses from the user_service
// refreshAccessToken endpoint.
func DecodeRefreshAccessTokenResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*user_servicepb.RefreshAccessTokenResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "refreshAccessToken", "*user_servicepb.RefreshAccessTokenResponse", v)
	}
	res := NewRefreshAccessTokenResult(message)
	vres := &userserviceviews.Userresult{Projected: res, View: view}
	if err := userserviceviews.ValidateUserresult(vres); err != nil {
		return nil, err
	}
	return userservice.NewUserresult(vres), nil
}

// BuildLogoutFunc builds the remote method to invoke for "user_service"
// service "logout" endpoint.
func BuildLogoutFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Logout(ctx, reqpb.(*user_servicepb.LogoutRequest), opts...)
		}
		return grpccli.Logout(ctx, &user_servicepb.LogoutRequest{}, opts...)
	}
}

// EncodeLogoutRequest encodes requests sent to user_service logout endpoint.
func EncodeLogoutRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.LogoutPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "logout", "*userservice.LogoutPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewLogoutRequest(payload), nil
}

// DecodeLogoutResponse decodes responses from the user_service logout endpoint.
func DecodeLogoutResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*user_servicepb.LogoutResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "logout", "*user_servicepb.LogoutResponse", v)
	}
	res := NewLogoutResult(message)
	return res, nil
}

// BuildListUsersFunc builds the remote method to invoke for "user_service"
// service "listUsers" endpoint.
func BuildListUsersFunc(grpccli user_servicepb.UserServiceClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.ListUsers(ctx, reqpb.(*user_servicepb.ListUsersRequest), opts...)
		}
		return grpccli.ListUsers(ctx, &user_servicepb.ListUsersRequest{}, opts...)
	}
}

// EncodeListUsersRequest encodes requests sent to user_service listUsers
// endpoint.
func EncodeListUsersRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*userservice.ListUsersPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "listUsers", "*userservice.ListUsersPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewListUsersRequest(payload), nil
}

// DecodeListUsersResponse decodes responses from the user_service listUsers
// endpoint.
func DecodeListUsersResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*user_servicepb.ListUsersResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("user_service", "listUsers", "*user_servicepb.ListUsersResponse", v)
	}
	res := NewListUsersResult(message)
	return res, nil
}
