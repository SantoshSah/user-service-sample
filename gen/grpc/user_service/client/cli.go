// Code generated by goa v3.2.4, DO NOT EDIT.
//
// user_service gRPC client CLI support package
//
// Command:
// $ goa gen github.com/SantoshSah/user-service-sample/design

package client

import (
	"encoding/json"
	"fmt"

	user_servicepb "github.com/SantoshSah/user-service-sample/gen/grpc/user_service/pb"
	userservice "github.com/SantoshSah/user-service-sample/gen/user_service"
)

// BuildSignupPayload builds the payload for the user_service signup endpoint
// from CLI flags.
func BuildSignupPayload(userServiceSignupMessage string) (*userservice.SignupPayload, error) {
	var err error
	var message user_servicepb.SignupRequest
	{
		if userServiceSignupMessage != "" {
			err = json.Unmarshal([]byte(userServiceSignupMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"Qui aspernatur aliquid illum qui est.\",\n      \"tenant\": \"Ut recusandae.\"\n   }'")
			}
		}
	}
	v := &userservice.SignupPayload{
		Email: message.Email,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}

	return v, nil
}

// BuildVerifyConfirmationTokenPayload builds the payload for the user_service
// verifyConfirmationToken endpoint from CLI flags.
func BuildVerifyConfirmationTokenPayload(userServiceVerifyConfirmationTokenMessage string) (*userservice.VerifyConfirmationTokenPayload, error) {
	var err error
	var message user_servicepb.VerifyConfirmationTokenRequest
	{
		if userServiceVerifyConfirmationTokenMessage != "" {
			err = json.Unmarshal([]byte(userServiceVerifyConfirmationTokenMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"confirmationToken\": 3893034289315717293,\n      \"tenant\": \"Sit similique reiciendis.\",\n      \"userId\": \"Quo praesentium quidem possimus.\"\n   }'")
			}
		}
	}
	v := &userservice.VerifyConfirmationTokenPayload{
		UserID:            message.UserId,
		ConfirmationToken: message.ConfirmationToken,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}

	return v, nil
}

// BuildUpdateUsernamePayload builds the payload for the user_service
// updateUsername endpoint from CLI flags.
func BuildUpdateUsernamePayload(userServiceUpdateUsernameMessage string, userServiceUpdateUsernameToken string) (*userservice.UpdateUsernamePayload, error) {
	var err error
	var message user_servicepb.UpdateUsernameRequest
	{
		if userServiceUpdateUsernameMessage != "" {
			err = json.Unmarshal([]byte(userServiceUpdateUsernameMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"Aperiam molestias sapiente non est.\",\n      \"tenant\": \"Qui vel unde id.\"\n   }'")
			}
		}
	}
	var token string
	{
		token = userServiceUpdateUsernameToken
	}
	v := &userservice.UpdateUsernamePayload{
		Name: message.Name,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}
	v.Token = token

	return v, nil
}

// BuildVerifyPasswordResetTokenPayload builds the payload for the user_service
// verifyPasswordResetToken endpoint from CLI flags.
func BuildVerifyPasswordResetTokenPayload(userServiceVerifyPasswordResetTokenMessage string) (*userservice.VerifyPasswordResetTokenPayload, error) {
	var err error
	var message user_servicepb.VerifyPasswordResetTokenRequest
	{
		if userServiceVerifyPasswordResetTokenMessage != "" {
			err = json.Unmarshal([]byte(userServiceVerifyPasswordResetTokenMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"passwordResetToken\": 14868537441258973258,\n      \"tenant\": \"Dolor dolorum aspernatur quam quos cum.\",\n      \"userId\": \"Aut dolores ratione deserunt nisi voluptatem.\"\n   }'")
			}
		}
	}
	v := &userservice.VerifyPasswordResetTokenPayload{
		UserID:             message.UserId,
		PasswordResetToken: message.PasswordResetToken,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}

	return v, nil
}

// BuildResetPasswordPayload builds the payload for the user_service
// resetPassword endpoint from CLI flags.
func BuildResetPasswordPayload(userServiceResetPasswordMessage string) (*userservice.ResetPasswordPayload, error) {
	var err error
	var message user_servicepb.ResetPasswordRequest
	{
		if userServiceResetPasswordMessage != "" {
			err = json.Unmarshal([]byte(userServiceResetPasswordMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"Quis amet corrupti illum doloribus.\",\n      \"tenant\": \"Repellat voluptatem explicabo quia officia est.\"\n   }'")
			}
		}
	}
	v := &userservice.ResetPasswordPayload{
		Email: message.Email,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}

	return v, nil
}

// BuildChangePasswordPayload builds the payload for the user_service
// changePassword endpoint from CLI flags.
func BuildChangePasswordPayload(userServiceChangePasswordMessage string, userServiceChangePasswordToken string) (*userservice.ChangePasswordPayload, error) {
	var err error
	var message user_servicepb.ChangePasswordRequest
	{
		if userServiceChangePasswordMessage != "" {
			err = json.Unmarshal([]byte(userServiceChangePasswordMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"password\": \"Quo suscipit.\",\n      \"tenant\": \"Ut adipisci non.\"\n   }'")
			}
		}
	}
	var token string
	{
		token = userServiceChangePasswordToken
	}
	v := &userservice.ChangePasswordPayload{
		Password: message.Password,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}
	v.Token = token

	return v, nil
}

// BuildLoginPayload builds the payload for the user_service login endpoint
// from CLI flags.
func BuildLoginPayload(userServiceLoginMessage string) (*userservice.LoginPayload, error) {
	var err error
	var message user_servicepb.LoginRequest
	{
		if userServiceLoginMessage != "" {
			err = json.Unmarshal([]byte(userServiceLoginMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"Consequatur et quasi quisquam occaecati et quod.\",\n      \"password\": \"Dolores quam eum.\",\n      \"tenant\": \"Et ut sint voluptas veritatis est.\"\n   }'")
			}
		}
	}
	v := &userservice.LoginPayload{
		Email:    message.Email,
		Password: message.Password,
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}

	return v, nil
}

// BuildRefreshAccessTokenPayload builds the payload for the user_service
// refreshAccessToken endpoint from CLI flags.
func BuildRefreshAccessTokenPayload(userServiceRefreshAccessTokenMessage string, userServiceRefreshAccessTokenToken string) (*userservice.RefreshAccessTokenPayload, error) {
	var err error
	var message user_servicepb.RefreshAccessTokenRequest
	{
		if userServiceRefreshAccessTokenMessage != "" {
			err = json.Unmarshal([]byte(userServiceRefreshAccessTokenMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tenant\": \"Veniam nostrum veritatis.\"\n   }'")
			}
		}
	}
	var token string
	{
		token = userServiceRefreshAccessTokenToken
	}
	v := &userservice.RefreshAccessTokenPayload{}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}
	v.Token = token

	return v, nil
}

// BuildLogoutPayload builds the payload for the user_service logout endpoint
// from CLI flags.
func BuildLogoutPayload(userServiceLogoutMessage string, userServiceLogoutToken string) (*userservice.LogoutPayload, error) {
	var err error
	var message user_servicepb.LogoutRequest
	{
		if userServiceLogoutMessage != "" {
			err = json.Unmarshal([]byte(userServiceLogoutMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tenant\": \"Dignissimos totam.\"\n   }'")
			}
		}
	}
	var token string
	{
		token = userServiceLogoutToken
	}
	v := &userservice.LogoutPayload{}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}
	v.Token = token

	return v, nil
}

// BuildListUsersPayload builds the payload for the user_service listUsers
// endpoint from CLI flags.
func BuildListUsersPayload(userServiceListUsersMessage string, userServiceListUsersToken string) (*userservice.ListUsersPayload, error) {
	var err error
	var message user_servicepb.ListUsersRequest
	{
		if userServiceListUsersMessage != "" {
			err = json.Unmarshal([]byte(userServiceListUsersMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"Dolorem facere velit labore architecto provident.\",\n      \"hasAgreed\": \"Excepturi rerum.\",\n      \"isActive\": \"Veritatis sit eos ad.\",\n      \"isVerified\": \"Magnam quod sunt ut quidem recusandae.\",\n      \"mobileNumber\": \"Voluptas facilis amet et.\",\n      \"name\": \"Assumenda hic amet beatae.\",\n      \"pageNumber\": 61737174172464830,\n      \"pageSize\": 6024070167591937614,\n      \"role\": \"Quia molestias enim.\",\n      \"tenant\": \"Quis tenetur vitae consequatur suscipit accusantium.\"\n   }'")
			}
		}
	}
	var token string
	{
		token = userServiceListUsersToken
	}
	v := &userservice.ListUsersPayload{}
	if message.Email != "" {
		v.Email = &message.Email
	}
	if message.MobileNumber != "" {
		v.MobileNumber = &message.MobileNumber
	}
	if message.Name != "" {
		v.Name = &message.Name
	}
	if message.IsActive != "" {
		v.IsActive = &message.IsActive
	}
	if message.IsVerified != "" {
		v.IsVerified = &message.IsVerified
	}
	if message.HasAgreed != "" {
		v.HasAgreed = &message.HasAgreed
	}
	if message.Role != "" {
		v.Role = &message.Role
	}
	if message.PageNumber != 0 {
		pageNumberptr := int(message.PageNumber)
		v.PageNumber = &pageNumberptr
	}
	if message.PageSize != 0 {
		pageSizeptr := int(message.PageSize)
		v.PageSize = &pageSizeptr
	}
	if message.Tenant != "" {
		v.Tenant = &message.Tenant
	}
	v.Token = token

	return v, nil
}
