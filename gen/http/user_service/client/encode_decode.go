// Code generated by goa v3.2.4, DO NOT EDIT.
//
// user_service HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/SantoshSah/user-service-sample/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	userservice "github.com/SantoshSah/user-service-sample/gen/user_service"
	userserviceviews "github.com/SantoshSah/user-service-sample/gen/user_service/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildSignupRequest instantiates a HTTP request object with method and path
// set to call the "user_service" service "signup" endpoint
func (c *Client) BuildSignupRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SignupUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "signup", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSignupRequest returns an encoder for requests sent to the user_service
// signup server.
func EncodeSignupRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.SignupPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "signup", "*userservice.SignupPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		body := NewSignupRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "signup", err)
		}
		return nil
	}
}

// DecodeSignupResponse returns a decoder for responses returned by the
// user_service signup endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeSignupResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeSignupResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SignupResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "signup", err)
			}
			p := NewSignupUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "signup", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body SignupNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "signup", err)
			}
			err = ValidateSignupNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "signup", err)
			}
			return nil, NewSignupNotFound(&body)
		case http.StatusBadRequest:
			var (
				body SignupBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "signup", err)
			}
			err = ValidateSignupBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "signup", err)
			}
			return nil, NewSignupBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "signup", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyConfirmationTokenRequest instantiates a HTTP request object with
// method and path set to call the "user_service" service
// "verifyConfirmationToken" endpoint
func (c *Client) BuildVerifyConfirmationTokenRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyConfirmationTokenUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "verifyConfirmationToken", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyConfirmationTokenRequest returns an encoder for requests sent to
// the user_service verifyConfirmationToken server.
func EncodeVerifyConfirmationTokenRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.VerifyConfirmationTokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "verifyConfirmationToken", "*userservice.VerifyConfirmationTokenPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		body := NewVerifyConfirmationTokenRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "verifyConfirmationToken", err)
		}
		return nil
	}
}

// DecodeVerifyConfirmationTokenResponse returns a decoder for responses
// returned by the user_service verifyConfirmationToken endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeVerifyConfirmationTokenResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeVerifyConfirmationTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyConfirmationTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyConfirmationToken", err)
			}
			p := NewVerifyConfirmationTokenUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyConfirmationToken", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body VerifyConfirmationTokenNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyConfirmationToken", err)
			}
			err = ValidateVerifyConfirmationTokenNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyConfirmationToken", err)
			}
			return nil, NewVerifyConfirmationTokenNotFound(&body)
		case http.StatusBadRequest:
			var (
				body VerifyConfirmationTokenBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyConfirmationToken", err)
			}
			err = ValidateVerifyConfirmationTokenBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyConfirmationToken", err)
			}
			return nil, NewVerifyConfirmationTokenBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "verifyConfirmationToken", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateUsernameRequest instantiates a HTTP request object with method
// and path set to call the "user_service" service "updateUsername" endpoint
func (c *Client) BuildUpdateUsernameRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateUsernameUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "updateUsername", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateUsernameRequest returns an encoder for requests sent to the
// user_service updateUsername server.
func EncodeUpdateUsernameRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.UpdateUsernamePayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "updateUsername", "*userservice.UpdateUsernamePayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateUsernameRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "updateUsername", err)
		}
		return nil
	}
}

// DecodeUpdateUsernameResponse returns a decoder for responses returned by the
// user_service updateUsername endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeUpdateUsernameResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeUpdateUsernameResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateUsernameResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "updateUsername", err)
			}
			p := NewUpdateUsernameUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "updateUsername", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body UpdateUsernameNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "updateUsername", err)
			}
			err = ValidateUpdateUsernameNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "updateUsername", err)
			}
			return nil, NewUpdateUsernameNotFound(&body)
		case http.StatusBadRequest:
			var (
				body UpdateUsernameBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "updateUsername", err)
			}
			err = ValidateUpdateUsernameBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "updateUsername", err)
			}
			return nil, NewUpdateUsernameBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "updateUsername", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyPasswordResetTokenRequest instantiates a HTTP request object with
// method and path set to call the "user_service" service
// "verifyPasswordResetToken" endpoint
func (c *Client) BuildVerifyPasswordResetTokenRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyPasswordResetTokenUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "verifyPasswordResetToken", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyPasswordResetTokenRequest returns an encoder for requests sent
// to the user_service verifyPasswordResetToken server.
func EncodeVerifyPasswordResetTokenRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.VerifyPasswordResetTokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "verifyPasswordResetToken", "*userservice.VerifyPasswordResetTokenPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		body := NewVerifyPasswordResetTokenRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "verifyPasswordResetToken", err)
		}
		return nil
	}
}

// DecodeVerifyPasswordResetTokenResponse returns a decoder for responses
// returned by the user_service verifyPasswordResetToken endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeVerifyPasswordResetTokenResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeVerifyPasswordResetTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyPasswordResetTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyPasswordResetToken", err)
			}
			p := NewVerifyPasswordResetTokenUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyPasswordResetToken", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body VerifyPasswordResetTokenNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyPasswordResetToken", err)
			}
			err = ValidateVerifyPasswordResetTokenNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyPasswordResetToken", err)
			}
			return nil, NewVerifyPasswordResetTokenNotFound(&body)
		case http.StatusBadRequest:
			var (
				body VerifyPasswordResetTokenBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "verifyPasswordResetToken", err)
			}
			err = ValidateVerifyPasswordResetTokenBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "verifyPasswordResetToken", err)
			}
			return nil, NewVerifyPasswordResetTokenBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "verifyPasswordResetToken", resp.StatusCode, string(body))
		}
	}
}

// BuildResetPasswordRequest instantiates a HTTP request object with method and
// path set to call the "user_service" service "resetPassword" endpoint
func (c *Client) BuildResetPasswordRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ResetPasswordUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "resetPassword", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeResetPasswordRequest returns an encoder for requests sent to the
// user_service resetPassword server.
func EncodeResetPasswordRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.ResetPasswordPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "resetPassword", "*userservice.ResetPasswordPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		body := NewResetPasswordRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "resetPassword", err)
		}
		return nil
	}
}

// DecodeResetPasswordResponse returns a decoder for responses returned by the
// user_service resetPassword endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeResetPasswordResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeResetPasswordResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ResetPasswordResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "resetPassword", err)
			}
			p := NewResetPasswordUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "resetPassword", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ResetPasswordNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "resetPassword", err)
			}
			err = ValidateResetPasswordNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "resetPassword", err)
			}
			return nil, NewResetPasswordNotFound(&body)
		case http.StatusBadRequest:
			var (
				body ResetPasswordBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "resetPassword", err)
			}
			err = ValidateResetPasswordBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "resetPassword", err)
			}
			return nil, NewResetPasswordBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "resetPassword", resp.StatusCode, string(body))
		}
	}
}

// BuildChangePasswordRequest instantiates a HTTP request object with method
// and path set to call the "user_service" service "changePassword" endpoint
func (c *Client) BuildChangePasswordRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ChangePasswordUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "changePassword", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeChangePasswordRequest returns an encoder for requests sent to the
// user_service changePassword server.
func EncodeChangePasswordRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.ChangePasswordPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "changePassword", "*userservice.ChangePasswordPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewChangePasswordRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "changePassword", err)
		}
		return nil
	}
}

// DecodeChangePasswordResponse returns a decoder for responses returned by the
// user_service changePassword endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeChangePasswordResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeChangePasswordResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ChangePasswordResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "changePassword", err)
			}
			p := NewChangePasswordUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "changePassword", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ChangePasswordNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "changePassword", err)
			}
			err = ValidateChangePasswordNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "changePassword", err)
			}
			return nil, NewChangePasswordNotFound(&body)
		case http.StatusBadRequest:
			var (
				body ChangePasswordBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "changePassword", err)
			}
			err = ValidateChangePasswordBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "changePassword", err)
			}
			return nil, NewChangePasswordBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "changePassword", resp.StatusCode, string(body))
		}
	}
}

// BuildLoginRequest instantiates a HTTP request object with method and path
// set to call the "user_service" service "login" endpoint
func (c *Client) BuildLoginRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LoginUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "login", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLoginRequest returns an encoder for requests sent to the user_service
// login server.
func EncodeLoginRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.LoginPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "login", "*userservice.LoginPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		body := NewLoginRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "login", err)
		}
		return nil
	}
}

// DecodeLoginResponse returns a decoder for responses returned by the
// user_service login endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeLoginResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeLoginResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LoginResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "login", err)
			}
			p := NewLoginUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "login", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body LoginNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "login", err)
			}
			err = ValidateLoginNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "login", err)
			}
			return nil, NewLoginNotFound(&body)
		case http.StatusBadRequest:
			var (
				body LoginBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "login", err)
			}
			err = ValidateLoginBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "login", err)
			}
			return nil, NewLoginBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "login", resp.StatusCode, string(body))
		}
	}
}

// BuildRefreshAccessTokenRequest instantiates a HTTP request object with
// method and path set to call the "user_service" service "refreshAccessToken"
// endpoint
func (c *Client) BuildRefreshAccessTokenRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RefreshAccessTokenUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "refreshAccessToken", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRefreshAccessTokenRequest returns an encoder for requests sent to the
// user_service refreshAccessToken server.
func EncodeRefreshAccessTokenRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.RefreshAccessTokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "refreshAccessToken", "*userservice.RefreshAccessTokenPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeRefreshAccessTokenResponse returns a decoder for responses returned by
// the user_service refreshAccessToken endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeRefreshAccessTokenResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeRefreshAccessTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RefreshAccessTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "refreshAccessToken", err)
			}
			p := NewRefreshAccessTokenUserresultOK(&body)
			view := "default"
			vres := &userserviceviews.Userresult{Projected: p, View: view}
			if err = userserviceviews.ValidateUserresult(vres); err != nil {
				return nil, goahttp.ErrValidationError("user_service", "refreshAccessToken", err)
			}
			res := userservice.NewUserresult(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body RefreshAccessTokenNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "refreshAccessToken", err)
			}
			err = ValidateRefreshAccessTokenNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "refreshAccessToken", err)
			}
			return nil, NewRefreshAccessTokenNotFound(&body)
		case http.StatusBadRequest:
			var (
				body RefreshAccessTokenBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "refreshAccessToken", err)
			}
			err = ValidateRefreshAccessTokenBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "refreshAccessToken", err)
			}
			return nil, NewRefreshAccessTokenBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "refreshAccessToken", resp.StatusCode, string(body))
		}
	}
}

// BuildLogoutRequest instantiates a HTTP request object with method and path
// set to call the "user_service" service "logout" endpoint
func (c *Client) BuildLogoutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LogoutUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "logout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLogoutRequest returns an encoder for requests sent to the user_service
// logout server.
func EncodeLogoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.LogoutPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "logout", "*userservice.LogoutPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeLogoutResponse returns a decoder for responses returned by the
// user_service logout endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeLogoutResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeLogoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LogoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "logout", err)
			}
			res := NewLogoutMessageResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body LogoutNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "logout", err)
			}
			err = ValidateLogoutNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "logout", err)
			}
			return nil, NewLogoutNotFound(&body)
		case http.StatusBadRequest:
			var (
				body LogoutBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "logout", err)
			}
			err = ValidateLogoutBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "logout", err)
			}
			return nil, NewLogoutBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "logout", resp.StatusCode, string(body))
		}
	}
}

// BuildListUsersRequest instantiates a HTTP request object with method and
// path set to call the "user_service" service "listUsers" endpoint
func (c *Client) BuildListUsersRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListUsersUserServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("user_service", "listUsers", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListUsersRequest returns an encoder for requests sent to the
// user_service listUsers server.
func EncodeListUsersRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*userservice.ListUsersPayload)
		if !ok {
			return goahttp.ErrInvalidType("user_service", "listUsers", "*userservice.ListUsersPayload", v)
		}
		if p.Tenant != nil {
			head := *p.Tenant
			req.Header.Set("tenant", head)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewListUsersRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("user_service", "listUsers", err)
		}
		return nil
	}
}

// DecodeListUsersResponse returns a decoder for responses returned by the
// user_service listUsers endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListUsersResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeListUsersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListUsersResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "listUsers", err)
			}
			res := NewListUsersResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListUsersNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "listUsers", err)
			}
			err = ValidateListUsersNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "listUsers", err)
			}
			return nil, NewListUsersNotFound(&body)
		case http.StatusBadRequest:
			var (
				body ListUsersBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("user_service", "listUsers", err)
			}
			err = ValidateListUsersBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("user_service", "listUsers", err)
			}
			return nil, NewListUsersBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("user_service", "listUsers", resp.StatusCode, string(body))
		}
	}
}

// unmarshalUserroleresultResponseBodyToUserserviceviewsUserroleresultView
// builds a value of type *userserviceviews.UserroleresultView from a value of
// type *UserroleresultResponseBody.
func unmarshalUserroleresultResponseBodyToUserserviceviewsUserroleresultView(v *UserroleresultResponseBody) *userserviceviews.UserroleresultView {
	if v == nil {
		return nil
	}
	res := &userserviceviews.UserroleresultView{
		ID:       v.ID,
		UserID:   v.UserID,
		RoleID:   v.RoleID,
		IsActive: v.IsActive,
	}
	if v.Role != nil {
		res.Role = unmarshalRoleresultResponseBodyToUserserviceviewsRoleresultView(v.Role)
	}

	return res
}

// unmarshalRoleresultResponseBodyToUserserviceviewsRoleresultView builds a
// value of type *userserviceviews.RoleresultView from a value of type
// *RoleresultResponseBody.
func unmarshalRoleresultResponseBodyToUserserviceviewsRoleresultView(v *RoleresultResponseBody) *userserviceviews.RoleresultView {
	if v == nil {
		return nil
	}
	res := &userserviceviews.RoleresultView{
		ID:        v.ID,
		Name:      v.Name,
		ServiceID: v.ServiceID,
		IsActive:  v.IsActive,
	}

	return res
}

// unmarshalUserresultResponseBodyToUserserviceUserresult builds a value of
// type *userservice.Userresult from a value of type *UserresultResponseBody.
func unmarshalUserresultResponseBodyToUserserviceUserresult(v *UserresultResponseBody) *userservice.Userresult {
	if v == nil {
		return nil
	}
	res := &userservice.Userresult{
		ID:           v.ID,
		Email:        v.Email,
		Name:         v.Name,
		IsVerified:   v.IsVerified,
		IsActive:     v.IsActive,
		HasAgreed:    v.HasAgreed,
		AccessToken:  v.AccessToken,
		RefreshToken: v.RefreshToken,
	}
	if v.Roles != nil {
		res.Roles = make([]*userservice.Userroleresult, len(v.Roles))
		for i, val := range v.Roles {
			res.Roles[i] = unmarshalUserroleresultResponseBodyToUserserviceUserroleresult(val)
		}
	}

	return res
}

// unmarshalUserroleresultResponseBodyToUserserviceUserroleresult builds a
// value of type *userservice.Userroleresult from a value of type
// *UserroleresultResponseBody.
func unmarshalUserroleresultResponseBodyToUserserviceUserroleresult(v *UserroleresultResponseBody) *userservice.Userroleresult {
	if v == nil {
		return nil
	}
	res := &userservice.Userroleresult{
		ID:       v.ID,
		UserID:   v.UserID,
		RoleID:   v.RoleID,
		IsActive: v.IsActive,
	}
	if v.Role != nil {
		res.Role = unmarshalRoleresultResponseBodyToUserserviceRoleresult(v.Role)
	}

	return res
}

// unmarshalRoleresultResponseBodyToUserserviceRoleresult builds a value of
// type *userservice.Roleresult from a value of type *RoleresultResponseBody.
func unmarshalRoleresultResponseBodyToUserserviceRoleresult(v *RoleresultResponseBody) *userservice.Roleresult {
	if v == nil {
		return nil
	}
	res := &userservice.Roleresult{
		ID:        v.ID,
		Name:      v.Name,
		ServiceID: v.ServiceID,
		IsActive:  v.IsActive,
	}

	return res
}

// unmarshalPageinfoResponseBodyToUserservicePageinfo builds a value of type
// *userservice.Pageinfo from a value of type *PageinfoResponseBody.
func unmarshalPageinfoResponseBodyToUserservicePageinfo(v *PageinfoResponseBody) *userservice.Pageinfo {
	if v == nil {
		return nil
	}
	res := &userservice.Pageinfo{
		PageNumber: v.PageNumber,
		PageSize:   v.PageSize,
		Count:      v.Count,
		TotalCount: v.TotalCount,
	}

	return res
}
